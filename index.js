// Generated by CoffeeScript 1.9.0
(function() {
  var App, PF, drawPath, fillPath, handleErrors, readline, renderCanvas, rl, termCanvas;

  App = {};

  readline = require('readline');

  PF = require('pathfinding');

  termCanvas = require('term-canvas');

  handleErrors = function(command) {
    switch (command[0]) {
      case 'C':
        if (command.length < 3) {
          console.log("\n Please pass the parameters needed. \n");
          return true;
        }
        break;
      case 'L':
      case 'R':
        if (command.length < 5) {
          console.log("\n Please pass the parameters needed. \n");
          return true;
        }
        break;
      case 'B':
        if (command.length < 4) {
          console.log("\n Please pass the parameters needed. \n");
          return true;
        }
        break;
      default:
        break;
    }
    if (!App.c && command[0] !== 'C') {
      console.log("\n Please create a canvas first. \n");
      return true;
    }
  };

  renderCanvas = function() {
    var x, y;
    App.c = new termCanvas(App.w, App.h);
    App.ctx = App.c.getContext('2d');
    App.g = new PF.Grid(App.w, App.h);
    App.ctx.clear();
    App.ctx.font = 'bold 12px sans-serif';
    x = 0;
    while (x < App.w) {
      App.ctx.fillText('-', x, 0);
      App.ctx.fillText('-', x, App.h);
      x = x + 1;
    }
    y = 2;
    while (y < App.h) {
      App.ctx.fillText('|', 0, y);
      App.ctx.fillText('|', App.w - 1, y);
      y = y + 1;
    }
    App.ctx.fillRect(10, 10, 10, 10);
    App.ctx.save();
    App.ctx.resetState();
    return console.log('\n');
  };

  drawPath = function(x1, y1, x2, y2) {
    var p, path, _i, _len, _results;
    App.g = App.g.clone();
    App.f = new PF.BiBreadthFirstFinder();
    path = App.f.findPath(x1, y1, x2, y2, App.g);
    _results = [];
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      p = path[_i];
      App.ctx.fillText('x', p[0], p[1]);
      _results.push(App.g.setWalkableAt(p[0], p[1], false));
    }
    return _results;
  };

  fillPath = function(x, y, c) {
    var height, width;
    width = App.c.width - 1;
    height = App.c.height + 1;
    if (!App.g.isWalkableAt(x, y)) {
      return true;
    }
    App.ctx.fillText(c, x, y);
    App.g.setWalkableAt(x, y, false);
    if (x > 2) {
      fillPath(x - 1, y, c);
    }
    if (y > 2) {
      fillPath(x, y - 1, c);
    }
    if (x < width - 1) {
      fillPath(x + 1, y, c);
    }
    if (y < height - 1) {
      return fillPath(x, y + 1, c);
    }
  };

  rl = readline.createInterface(process.stdin, process.stdout);

  rl.setPrompt('Enter command: ');

  rl.prompt();

  rl.on('line', function(l) {
    var c, command, x, x1, x2, y, y1, y2;
    command = l.trim();
    command = command.split(/[ ,]+/);
    switch (command[0]) {
      case 'C':
        if (!handleErrors(command)) {

        } else {
          break;
        }
        App.w = parseInt(command[1], 10);
        App.h = parseInt(command[2], 10);
        App.w = App.w + 2;
        App.h = App.h + 2;
        renderCanvas();
        break;
      case 'L':
        if (!handleErrors(command)) {

        } else {
          break;
        }
        x1 = parseInt(command[1], 10);
        y1 = parseInt(command[2], 10);
        x2 = parseInt(command[3], 10);
        y2 = parseInt(command[4], 10);
        drawPath(x1 + 1, y1 + 1, x2 + 1, y2 + 1);
        App.ctx.fillRect(10, 10, 10, 10);
        App.ctx.save();
        break;
      case 'R':
        if (!handleErrors(command)) {

        } else {
          break;
        }
        x1 = parseInt(command[1], 10);
        y1 = parseInt(command[2], 10);
        x2 = parseInt(command[3], 10);
        y2 = parseInt(command[4], 10);
        y1 += 1;
        y2 += 1;
        drawPath(x1, y1, x2, y1);
        drawPath(x1, y1, x1, y2);
        drawPath(x2, y1, x2, y2);
        drawPath(x1, y2, x2, y2);
        App.ctx.fillRect(10, 10, 10, 10);
        App.ctx.save();
        break;
      case 'B':
        if (!handleErrors(command)) {

        } else {
          break;
        }
        x = parseInt(command[1], 10);
        y = parseInt(command[2], 10);
        c = command[3];
        x += 1;
        y += 1;
        fillPath(x, y, c);
        App.ctx.fillRect(10, 10, 10, 10);
        App.ctx.save();
        break;
      case 'Q':
        process.exit(0);
        break;
      default:
        console.log('\n `' + command[0] + '` is not a supported command. \n');
        break;
    }
    rl.prompt();
  }).on('close', function() {
    process.exit(0);
  });

}).call(this);
