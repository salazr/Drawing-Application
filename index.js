// Generated by CoffeeScript 1.9.0
(function() {
  var App, PF, drawPath, readline, renderCanvas, rl, termCanvas;

  App = {};

  readline = require('readline');

  PF = require('pathfinding');

  termCanvas = require('term-canvas');

  renderCanvas = function() {
    var x, y;
    App.c = new termCanvas(App.w, App.h);
    App.ctx = App.c.getContext('2d');
    App.ctx.clear();
    x = 0;
    while (x < App.w) {
      App.ctx.fillText('-', x, 0);
      App.ctx.fillText('-', x, App.h);
      x = x + 1;
    }
    y = 2;
    while (y < App.h) {
      App.ctx.fillText('|', 0, y);
      App.ctx.fillText('|', App.w - 1, y);
      y = y + 1;
    }
    App.ctx.fillRect(10, 10, 10, 10);
    App.ctx.save();
    App.ctx.resetState();
    return console.log('\n');
  };

  drawPath = function(x1, y1, x2, y2) {
    var p, path, _i, _len, _results;
    App.g = App.g.clone();
    App.f = new PF.BiBreadthFirstFinder();
    path = App.f.findPath(x1, y1, x2, y2, App.g);
    _results = [];
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      p = path[_i];
      App.ctx.font = 'bold 12px sans-serif';
      App.ctx.fillText('x', p[0], p[1]);
      _results.push(App.g.setWalkableAt(p[0], p[1], false));
    }
    return _results;
  };

  rl = readline.createInterface(process.stdin, process.stdout);

  rl.setPrompt('Enter command: ');

  rl.prompt();

  rl.on('line', function(l) {
    var c, column, command, p, path, row, x, x1, x2, y, y1, y2, _i, _j, _k, _len, _len1, _len2, _ref;
    command = l.trim();
    command = command.split(/[ ,]+/);
    switch (command[0]) {
      case 'C':
        App.w = parseInt(command[1], 10);
        App.h = parseInt(command[2], 10);
        App.w = App.w + 2;
        App.h = App.h + 2;
        renderCanvas();
        break;
      case 'L':
        x1 = parseInt(command[1], 10);
        y1 = parseInt(command[2], 10);
        x2 = parseInt(command[3], 10);
        y2 = parseInt(command[4], 10);
        App.g = new PF.Grid(App.w, App.h);
        App.f = new PF.BiBreadthFirstFinder();
        path = App.f.findPath(x1 + 1, y1 + 1, x2 + 1, y2 + 1, App.g);
        for (_i = 0, _len = path.length; _i < _len; _i++) {
          p = path[_i];
          App.ctx.font = 'bold 12px sans-serif';
          App.ctx.fillText('x', p[0], p[1]);
        }
        App.ctx.fillRect(10, 10, 10, 10);
        App.ctx.save();
        break;
      case 'R':
        x1 = parseInt(command[1], 10);
        y1 = parseInt(command[2], 10);
        x2 = parseInt(command[3], 10);
        y2 = parseInt(command[4], 10);
        x1 -= 1;
        x2 -= 1;
        y1 += 1;
        y2 += 1;
        App.g = new PF.Grid(App.w, App.h);
        drawPath(x1, y1, x2, y1);
        drawPath(x1, y1, x1, y2);
        drawPath(x2, y1, x2, y2);
        drawPath(x1, y2, x2, y2);
        App.ctx.fillRect(10, 10, 10, 10);
        App.ctx.save();
        break;
      case 'B':
        x = parseInt(command[1], 10);
        y = parseInt(command[2], 10);
        c = command[3];
        if (App.g) {

        } else {
          App.g = new PF.Grid(App.w, App.h);
        }
        _ref = App.g.nodes;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          row = _ref[_j];
          for (_k = 0, _len2 = row.length; _k < _len2; _k++) {
            column = row[_k];
            if (App.g.isWalkableAt(column.x, column.y)) {
              App.ctx.font = 'bold 12px sans-serif';
              App.ctx.fillText(c, column.x, column.y);
              App.g.setWalkableAt(column.x, column.y, false);
            }
          }
        }
        App.ctx.fillRect(10, 10, 10, 10);
        App.ctx.save();
        break;
      case 'Q':
        process.exit(0);
        break;
      default:
        console.log('\n `' + command[0] + '` is not a supported command. \n');
        break;
    }
    rl.prompt();
  }).on('close', function() {
    process.exit(0);
  });

}).call(this);
